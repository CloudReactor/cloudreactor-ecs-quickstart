project_name: "example-ecs-tasks"
project_version_text: 1.0.0
# Optionally, provide a steadily increasing number to indicate which build
# is more updated than another.
# project_version_number: 1
project_url: "https://github.com/CloudReactor/example-ecs-tasks"

# These settings will apply by default to all tasks and in all deployments.
# To let CloudReactor manage these settings, leave these settings blank.
default_task_config: &default_task_config
  command: "python main.py"
  #enabled: true
  #max_manual_start_delay_seconds: 60
  #heartbeat_interval_seconds: 300
  #max_heartbeat_lateness_seconds: 120
  #max_concurrency: 1
  #ecs:
    # To add extra containers to the task:
    # Extra CPU/memory allocated to the extra containers,
    # will be taken away from the total cpu_units and memory_mb
    # allocated for the entire task.
    #extra_container_cpu_units: 32
    #extra_container_memory_mb: 128
    # Each definition has the properties for containers in an AWS ECS task
    # definition,
    # The following example uses nginx as a reverse proxy. It assumed that a Docker image
    # based on nginx, with configuration, is available in ECR already.
    # See https://medium.com/@stefanofrancavilla/deploy-web-apps-nginx-to-ecs-with-docker-580c6af827e8
    # except ECS cluster configuration is not needed since we're using Fargate.
    # extra_container_definitions:
    #  - name: Some Container Name
    #    image: XXXXXXXXXX.dkr.ecr.us-west-2.amazonaws.com/configured-nginx
    #    cpu: 256
    #    memory: 1024
    #    essential: "true"
    #    portMappings:
    #      - containerPort: 80 # nginx default port is 80
    #      - hostPort: 8000    # port of the target group
    #      - protocol: tcp
    #
    # Uncomment to additional properties to the top-level ECS task definition:
    # extra_task_definition_properties:
    #   volumes:
    #     - name: "database_scratch"
    #       host: {}
    #   secrets:
    #     - name: environment_variable_name
    #       valueFrom: "arn:aws:ssm:region:aws_account_id:parameter/parameter_name"


  ecs: &default_task_ecs
    # See https://aws.amazon.com/fargate/pricing/
    # for supported combinations.
    cpu_units: 256
    memory_mb: 512
    task:
      network:
        # Set this to True if you are running on a public subnet.
        # If False, your subnet must have a NAT gateway configured so that it
        # can pull Docker images from ECR.
        assign_public_ip: True
    additional_container_definitions: []
  wrapper: &default_task_wrapper
    max_retries: 1
    heartbeat_interval_seconds: 30
  env: &default_task_env
    DEPLOYMENT: "{{env}}"

# These are per-task settings that will inherit and override the settings in
# default_task_config, in all environments.
task_name_to_config:
  main:
    <<: *default_task_config
    description: "Working Process"
    schedule: cron(5 14 * * ? *)
    # This task always fails
  fail:
    <<: *default_task_config
    description: "Failing Process"
    env:
      <<: *default_task_env
      ROW_TO_FAIL_AT: 3
    wrapper:
      <<: *default_task_wrapper
      max_retries: 2
  # This task always times out
  timeout:
    <<: *default_task_config
    description: "Long Process"
    env:
      <<: *default_task_env
      NUM_ROWS: 300
    max_age_seconds: 70
    wrapper:
      <<: *default_task_wrapper
      process_timeout_seconds: 10
      max_retries: 0
  ondemand:
    <<: *default_task_config
    description: "On-demand Process"
    command: "sleep 10"
    wrapper:
      # This data is sent back from the wrapper to CloudReactor when it starts.
      # It may be used to identify properties about instance of the task that is
      # running.
      other_instance_metadata:
        a: 'b'
        embedded:
          c: 'd'
          f: 1
  # This task sends status back to CloudReactor as it is running
  with_updates:
    <<: *default_task_config
    description: "On-demand Process"
    command: "python sleep_with_update.py"
    schedule: cron(9 15 * * ? *)
    wrapper:
      <<: *default_task_wrapper
      enable_status_updates: true
  # This is a service (i.e. perpetually running task)
  service:
    <<: *default_task_config
    description: "Service"
    is_service: True
    # Uncomment the following to control the instance count in code
    # rather than using whatever was last set in the dashboard.
    #service_instance_count: 1
    #min_service_instance_count: 1
    wrapper:
      <<: *default_task_wrapper
      max_retries: 0
  # This task shows how to use the temporary file system provided by ECS
  file_io:
    <<: *default_task_config
    description: "File I/O"
    command: "python file_io.py"
    ecs:
      <<: *default_task_ecs
      extra_main_container_properties:
        mountPoints:
          - sourceVolume: "database_scratch"
            containerPath: "/var/scratch"
      extra_task_definition_properties:
        volumes:
          - name: "database_scratch"
            host: {}
    env:
      <<: *default_task_env
      TEMP_FILE_DIR: "/var/scratch"
# Uncomment to enable web server -- requires an IP target group and
# load balancer setup in AWS
#  web_server:
#    <<: *default_task_config
#    description: "Web Server"
#    command: "flask run -p 7070 --host=0.0.0.0"
#    max_concurrency: null
#    is_service: True
#    # Uncomment the following to control the instance count in code
#    # rather than using whatever was last set in the dashboard.
#    #service_instance_count: 1
#    #min_service_instance_count: 1
#    ecs:
#      <<: *default_task_ecs
#      task:
#        network:
#          assign_public_ip: True
#      extra_main_container_properties:
#        portMappings:
#          - containerPort: 7070
#            protocol: tcp
#    env:
#      <<: *default_task_env
#      FLASK_APP: web_server.py
#    wrapper:
#      <<: *default_task_wrapper
#      max_retries: 0
